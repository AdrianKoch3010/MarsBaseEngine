<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MarsBaseEngine: mbe::HandleID&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Domex Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MarsBaseEngine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacembe.html">mbe</a></li><li class="navelem"><a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmbe_1_1_handle_i_d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mbe::HandleID&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Acts as a unique identifier for and smart pointer to an object.  
 <a href="classmbe_1_1_handle_i_d.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_handle_i_d_8h_source.html">HandleID.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2d86bfc21ca113ca987db8fed517a9c8"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a2d86bfc21ca113ca987db8fed517a9c8">UnderlyingType</a></td></tr>
<tr class="memdesc:a2d86bfc21ca113ca987db8fed517a9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the id type used to uniquely identify a handled object.  <a href="classmbe_1_1_handle_i_d.html#a2d86bfc21ca113ca987db8fed517a9c8">More...</a><br /></td></tr>
<tr class="separator:a2d86bfc21ca113ca987db8fed517a9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab624b6bb766de216bd273b12e1bb0424"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#ab624b6bb766de216bd273b12e1bb0424">HandleID</a> ()</td></tr>
<tr class="memdesc:ab624b6bb766de216bd273b12e1bb0424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classmbe_1_1_handle_i_d.html#ab624b6bb766de216bd273b12e1bb0424">More...</a><br /></td></tr>
<tr class="separator:ab624b6bb766de216bd273b12e1bb0424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e15c47584a2a2b3bbe45c63d106cd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#ae0e15c47584a2a2b3bbe45c63d106cd7">HandleID</a> (<a class="el" href="classmbe_1_1_handle_i_d.html#a2d86bfc21ca113ca987db8fed517a9c8">UnderlyingType</a> id)</td></tr>
<tr class="memdesc:ae0e15c47584a2a2b3bbe45c63d106cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from an underlying id.  <a href="classmbe_1_1_handle_i_d.html#ae0e15c47584a2a2b3bbe45c63d106cd7">More...</a><br /></td></tr>
<tr class="separator:ae0e15c47584a2a2b3bbe45c63d106cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baea0a6928bb3da16da13da920653c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a0baea0a6928bb3da16da13da920653c1">HandleID</a> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a> &amp;other)</td></tr>
<tr class="memdesc:a0baea0a6928bb3da16da13da920653c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classmbe_1_1_handle_i_d.html#a0baea0a6928bb3da16da13da920653c1">More...</a><br /></td></tr>
<tr class="separator:a0baea0a6928bb3da16da13da920653c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd435228ff0600eb798911823d13c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#af9cd435228ff0600eb798911823d13c9">operator=</a> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a> &amp;other)</td></tr>
<tr class="memdesc:af9cd435228ff0600eb798911823d13c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigmnet operator.  <a href="classmbe_1_1_handle_i_d.html#af9cd435228ff0600eb798911823d13c9">More...</a><br /></td></tr>
<tr class="separator:af9cd435228ff0600eb798911823d13c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7821b41cd492f5f1b2b7d66e3d43e05a"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, std::enable_if_t&lt;!std::is_same_v&lt; U, noConstT &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7821b41cd492f5f1b2b7d66e3d43e05a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a7821b41cd492f5f1b2b7d66e3d43e05a">HandleID</a> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; noConstT &gt; &amp;other)</td></tr>
<tr class="memdesc:a7821b41cd492f5f1b2b7d66e3d43e05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from HandleID&lt;T&gt; where T is not const.  <a href="classmbe_1_1_handle_i_d.html#a7821b41cd492f5f1b2b7d66e3d43e05a">More...</a><br /></td></tr>
<tr class="separator:a7821b41cd492f5f1b2b7d66e3d43e05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497dee90c82249e212a02a94f38de737"><td class="memTemplParams" colspan="2">template&lt;int... , typename U  = T, std::enable_if_t&lt;!std::is_same_v&lt; U, noConstT &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a497dee90c82249e212a02a94f38de737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a497dee90c82249e212a02a94f38de737">operator=</a> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; noConstT &gt; &amp;other)</td></tr>
<tr class="memdesc:a497dee90c82249e212a02a94f38de737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator from HandleID&lt;T&gt; where T is not const.  <a href="classmbe_1_1_handle_i_d.html#a497dee90c82249e212a02a94f38de737">More...</a><br /></td></tr>
<tr class="separator:a497dee90c82249e212a02a94f38de737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b90452b012815b500ed9245913216c"><td class="memItemLeft" align="right" valign="top"><a id="ac8b90452b012815b500ed9245913216c"></a>
<a class="el" href="classmbe_1_1_handle_i_d.html#a2d86bfc21ca113ca987db8fed517a9c8">UnderlyingType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#ac8b90452b012815b500ed9245913216c">GetUnderlyingID</a> () const</td></tr>
<tr class="memdesc:ac8b90452b012815b500ed9245913216c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying id. <br /></td></tr>
<tr class="separator:ac8b90452b012815b500ed9245913216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa93d414e5a41b385eac8e14a9f112e8"><td class="memItemLeft" align="right" valign="top">T *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#aaa93d414e5a41b385eac8e14a9f112e8">GetObjectPtr</a> () const</td></tr>
<tr class="memdesc:aaa93d414e5a41b385eac8e14a9f112e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives direct access to the managed object pointer.  <a href="classmbe_1_1_handle_i_d.html#aaa93d414e5a41b385eac8e14a9f112e8">More...</a><br /></td></tr>
<tr class="separator:aaa93d414e5a41b385eac8e14a9f112e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21df4248f0210546a43ead3039bc66c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#ab21df4248f0210546a43ead3039bc66c">GetExistingObject</a> () const</td></tr>
<tr class="memdesc:ab21df4248f0210546a43ead3039bc66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object that is known to still exist.  <a href="classmbe_1_1_handle_i_d.html#ab21df4248f0210546a43ead3039bc66c">More...</a><br /></td></tr>
<tr class="separator:ab21df4248f0210546a43ead3039bc66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0979d8741b2b7e3bf9c01b59b705903"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#ab0979d8741b2b7e3bf9c01b59b705903">operator*</a> () const</td></tr>
<tr class="memdesc:ab0979d8741b2b7e3bf9c01b59b705903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the dereference operator for easier object access.  <a href="classmbe_1_1_handle_i_d.html#ab0979d8741b2b7e3bf9c01b59b705903">More...</a><br /></td></tr>
<tr class="separator:ab0979d8741b2b7e3bf9c01b59b705903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7785a6aca722bcec4f2bf95db55be8"><td class="memItemLeft" align="right" valign="top">T *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#aae7785a6aca722bcec4f2bf95db55be8">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:aae7785a6aca722bcec4f2bf95db55be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the reffering operator for easier object access.  <a href="classmbe_1_1_handle_i_d.html#aae7785a6aca722bcec4f2bf95db55be8">More...</a><br /></td></tr>
<tr class="separator:aae7785a6aca722bcec4f2bf95db55be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956ebac36d1a83a73c1e643dc34687e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a956ebac36d1a83a73c1e643dc34687e2">Valid</a> () const</td></tr>
<tr class="memdesc:a956ebac36d1a83a73c1e643dc34687e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the id is valid.  <a href="classmbe_1_1_handle_i_d.html#a956ebac36d1a83a73c1e643dc34687e2">More...</a><br /></td></tr>
<tr class="separator:a956ebac36d1a83a73c1e643dc34687e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdd90902dabadb945136b5084a382ad"><td class="memTemplParams" colspan="2"><a id="affdd90902dabadb945136b5084a382ad"></a>
template&lt;typename U , std::enable_if_t&lt;!std::is_same_v&lt; U, std::remove_const_t&lt; T &gt;&gt;, int &gt; &gt; </td></tr>
<tr class="memitem:affdd90902dabadb945136b5084a382ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>HandleID</b> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; std::remove_const_t&lt; T &gt;&gt; &amp;other)</td></tr>
<tr class="separator:affdd90902dabadb945136b5084a382ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3ac392d31fbe353e330e6fd9f87ef0"><td class="memTemplParams" colspan="2"><a id="a8b3ac392d31fbe353e330e6fd9f87ef0"></a>
template&lt;int... , typename U , std::enable_if_t&lt;!std::is_same_v&lt; U, std::remove_const_t&lt; T &gt;&gt;, int &gt; &gt; </td></tr>
<tr class="memitem:a8b3ac392d31fbe353e330e6fd9f87ef0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; std::remove_const_t&lt; T &gt;&gt; &amp;other)</td></tr>
<tr class="separator:a8b3ac392d31fbe353e330e6fd9f87ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0e834491d710fbda64713d3b858c8090"><td class="memItemLeft" align="right" valign="top"><a id="a0e834491d710fbda64713d3b858c8090"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HandleBase&lt; T &gt;</b></td></tr>
<tr class="separator:a0e834491d710fbda64713d3b858c8090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26f862de7cc4ef22bdf04a23c81f415"><td class="memItemLeft" align="right" valign="top"><a id="ab26f862de7cc4ef22bdf04a23c81f415"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HandleID&lt; const T &gt;</b></td></tr>
<tr class="separator:ab26f862de7cc4ef22bdf04a23c81f415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2045e00166f79baf0b9a2bef020ea2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a8e2045e00166f79baf0b9a2bef020ea2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;id)</td></tr>
<tr class="memdesc:a8e2045e00166f79baf0b9a2bef020ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the id to be printed.  <a href="classmbe_1_1_handle_i_d.html#a8e2045e00166f79baf0b9a2bef020ea2">More...</a><br /></td></tr>
<tr class="separator:a8e2045e00166f79baf0b9a2bef020ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c614b91880492ceb6026dec34435ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a42c614b91880492ceb6026dec34435ea">operator==</a> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;left, const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a42c614b91880492ceb6026dec34435ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables two ids to be compared.  <a href="classmbe_1_1_handle_i_d.html#a42c614b91880492ceb6026dec34435ea">More...</a><br /></td></tr>
<tr class="separator:a42c614b91880492ceb6026dec34435ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0bddbbf109016d44a9b2868c4047a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#a3c0bddbbf109016d44a9b2868c4047a7">operator!=</a> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;left, const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a3c0bddbbf109016d44a9b2868c4047a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables two ids to be compared.  <a href="classmbe_1_1_handle_i_d.html#a3c0bddbbf109016d44a9b2868c4047a7">More...</a><br /></td></tr>
<tr class="separator:a3c0bddbbf109016d44a9b2868c4047a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea57c5a477a5d02f1579348655dc3c6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbe_1_1_handle_i_d.html#aea57c5a477a5d02f1579348655dc3c6f">operator&lt;</a> (const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;left, const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:aea57c5a477a5d02f1579348655dc3c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables two ids to be compared.  <a href="classmbe_1_1_handle_i_d.html#aea57c5a477a5d02f1579348655dc3c6f">More...</a><br /></td></tr>
<tr class="separator:aea57c5a477a5d02f1579348655dc3c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class mbe::HandleID&lt; T &gt;</h3>

<p>Acts as a unique identifier for and smart pointer to an object. </p>
<p>Provides a wrapper around an unsigned long long base type. For performance reasons, a pointer to the referenced object is cached. This object can be accessed through the interface provided by this class and const correctness will be preserved. If the referenced object gets deleted (or in case of the template specialisations for the <a class="el" href="classmbe_1_1_entity.html" title="An Object that can have multiple Components.">mbe::Entity</a> is no longer active), the <a class="el" href="classmbe_1_1_handle_i_d.html" title="Acts as a unique identifier for and smart pointer to an object.">HandleID</a> will no longer be valid. This class is the id used by the HandleBase&lt;TDerived&gt; template base class. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object to which the id refers. Note that the class will behave differently for const types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmbe_1_1_handle_base.html" title="Creates an id for the derived object and provides functionality to access it through an id.">HandleBase</a>, <a class="el" href="classmbe_1_1_handle_i_d_3_01_entity_01_4.html" title="Acts as a unique identifier for and smart pointer to an Entity.">HandleID&lt;Entity&gt;</a> and <a class="el" href="classmbe_1_1_handle_i_d_3_01const_01_entity_01_4.html" title="Acts as a unique identifier for and smart pointer to a const Entity.">HandleID&lt;const Entity&gt;</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2d86bfc21ca113ca987db8fed517a9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d86bfc21ca113ca987db8fed517a9c8">&#9670;&nbsp;</a></span>UnderlyingType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::<a class="el" href="classmbe_1_1_handle_i_d.html#a2d86bfc21ca113ca987db8fed517a9c8">UnderlyingType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the id type used to uniquely identify a handled object. </p>
<p>unsigned long long int (uint64_t) is the largest int type in C++. It allows for 18,446,744,073,709,551,615 unique ids. This is very unlikely to ever be reached. Note also that the ids will start from 0 for every derived type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab624b6bb766de216bd273b12e1bb0424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab624b6bb766de216bd273b12e1bb0424">&#9670;&nbsp;</a></span>HandleID() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::<a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initialises the object with null id </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmbe_1_1_handle_base.html#af687d9a9abd10de0c6be65dd01f9e689" title="Returns an id for which no object exists.">HandleBase&lt;TDerived&gt;::GetNullID()</a> </dd></dl>

</div>
</div>
<a id="ae0e15c47584a2a2b3bbe45c63d106cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e15c47584a2a2b3bbe45c63d106cd7">&#9670;&nbsp;</a></span>HandleID() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::<a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmbe_1_1_handle_i_d.html#a2d86bfc21ca113ca987db8fed517a9c8">UnderlyingType</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor from an underlying id. </p>
<p>This constructor is not explicit, so conversion from an underlying type is possible, i.e. HanldeID&lt;T&gt; id = 42 is valid syntax. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The underlying id of the object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0baea0a6928bb3da16da13da920653c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baea0a6928bb3da16da13da920653c1">&#9670;&nbsp;</a></span>HandleID() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::<a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classmbe_1_1_handle_i_d.html" title="Acts as a unique identifier for and smart pointer to an object.">HandleID</a> of the same type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7821b41cd492f5f1b2b7d66e3d43e05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7821b41cd492f5f1b2b7d66e3d43e05a">&#9670;&nbsp;</a></span>HandleID() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, std::enable_if_t&lt;!std::is_same_v&lt; U, noConstT &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::<a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; noConstT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor from HandleID&lt;T&gt; where T is not const. </p>
<p>This enables HandleID&lt;const T&gt; id(HandleID&lt;T&gt;()) but not HandleID&lt;T&gt; id(HandleID&lt;const T&gt;()). </p><dl class="section note"><dt>Note</dt><dd>This constructor is only enabled where T is const </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Same as T if T is const, disabed otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A <a class="el" href="classmbe_1_1_handle_i_d.html" title="Acts as a unique identifier for and smart pointer to an object.">HandleID</a> of the same template argument not const </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab21df4248f0210546a43ead3039bc66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21df4248f0210546a43ead3039bc66c">&#9670;&nbsp;</a></span>GetExistingObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::GetExistingObject</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an object that is known to still exist. </p>
<dl class="section note"><dt>Note</dt><dd>If the _DEBUG compiler flag is enabled, an IDNotFound exception will be thrown. In release mode this behaviour is disabled for performance reasons </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object </dd></dl>

</div>
</div>
<a id="aaa93d414e5a41b385eac8e14a9f112e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa93d414e5a41b385eac8e14a9f112e8">&#9670;&nbsp;</a></span>GetObjectPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* const <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::GetObjectPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives direct access to the managed object pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the object or nullptr if it has been deleted </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method exposes a raw pointer to an object that might memory managed elsewhere </dd></dl>

</div>
</div>
<a id="ab0979d8741b2b7e3bf9c01b59b705903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0979d8741b2b7e3bf9c01b59b705903">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the dereference operator for easier object access. </p>
<p>This is equivalent to <a class="el" href="classmbe_1_1_handle_i_d.html#ab21df4248f0210546a43ead3039bc66c" title="Get an object that is known to still exist.">GetExistingObject()</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmbe_1_1_handle_i_d.html#ab21df4248f0210546a43ead3039bc66c" title="Get an object that is known to still exist.">GetExistingObject()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the object </dd></dl>

</div>
</div>
<a id="aae7785a6aca722bcec4f2bf95db55be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7785a6aca722bcec4f2bf95db55be8">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* const <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the reffering operator for easier object access. </p>
<p>This is equivalent to &amp;<a class="el" href="classmbe_1_1_handle_i_d.html#ab21df4248f0210546a43ead3039bc66c" title="Get an object that is known to still exist.">GetExistingObject()</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmbe_1_1_handle_i_d.html#ab21df4248f0210546a43ead3039bc66c" title="Get an object that is known to still exist.">GetExistingObject()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the object </dd></dl>

</div>
</div>
<a id="af9cd435228ff0600eb798911823d13c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cd435228ff0600eb798911823d13c9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp; <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assigmnet operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classmbe_1_1_handle_i_d.html" title="Acts as a unique identifier for and smart pointer to an object.">HandleID</a> of the same type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classmbe_1_1_handle_i_d.html" title="Acts as a unique identifier for and smart pointer to an object.">HandleID</a> </dd></dl>

</div>
</div>
<a id="a497dee90c82249e212a02a94f38de737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497dee90c82249e212a02a94f38de737">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;int... , typename U  = T, std::enable_if_t&lt;!std::is_same_v&lt; U, noConstT &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&amp; <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; noConstT &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator from HandleID&lt;T&gt; where T is not const. </p>
<p>This enables HandleID&lt;const T&gt; id = <a class="el" href="classmbe_1_1_handle_i_d.html#ab624b6bb766de216bd273b12e1bb0424" title="Default constructor.">HandleID&lt;T&gt;()</a> but not HandleID&lt;T&gt; id = <a class="el" href="classmbe_1_1_handle_i_d.html#ab624b6bb766de216bd273b12e1bb0424" title="Default constructor.">HandleID&lt;const T&gt;()</a>. </p><dl class="section note"><dt>Note</dt><dd>This assignment operator is only enabled where T is const </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Same as T if T is const, disabed otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A <a class="el" href="classmbe_1_1_handle_i_d.html" title="Acts as a unique identifier for and smart pointer to an object.">HandleID</a> of the same template argument not const </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <a class="el" href="classmbe_1_1_handle_i_d.html" title="Acts as a unique identifier for and smart pointer to an object.">HandleID</a> </dd></dl>

</div>
</div>
<a id="a956ebac36d1a83a73c1e643dc34687e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956ebac36d1a83a73c1e643dc34687e2">&#9670;&nbsp;</a></span>Valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmbe_1_1_handle_i_d.html">mbe::HandleID</a>&lt; T &gt;::Valid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the id is valid. </p>
<p>Checks if the object has been deleted. This is done through a static dictionary shared with the <a class="el" href="classmbe_1_1_handle_base.html" title="Creates an id for the derived object and provides functionality to access it through an id.">HandleBase</a> template base class. The template specialisation for T = <a class="el" href="classmbe_1_1_entity.html" title="An Object that can have multiple Components.">Entity</a> and T = const <a class="el" href="classmbe_1_1_entity.html" title="An Object that can have multiple Components.">Entity</a> also checks if the entity is active. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classmbe_1_1_handle_i_d_3_01_entity_01_4.html" title="Acts as a unique identifier for and smart pointer to an Entity.">HandleID&lt;Entity&gt;</a> and <a class="el" href="classmbe_1_1_handle_i_d_3_01const_01_entity_01_4.html" title="Acts as a unique identifier for and smart pointer to a const Entity.">HandleID&lt;const Entity&gt;</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the object still exists, false otherwise </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3c0bddbbf109016d44a9b2868c4047a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0bddbbf109016d44a9b2868c4047a7">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables two ids to be compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand </td></tr>
    <tr><td class="paramname">right</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the underlying ids are different, false otherwise </dd></dl>

</div>
</div>
<a id="aea57c5a477a5d02f1579348655dc3c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea57c5a477a5d02f1579348655dc3c6f">&#9670;&nbsp;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables two ids to be compared. </p>
<dl class="section see"><dt>See also</dt><dd>std::hash&lt;mbe::HandleID&lt;T&gt;&gt; for use in a std::map </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand </td></tr>
    <tr><td class="paramname">right</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the underlying id of the left id is less than that of the right, false otherwise </dd></dl>

</div>
</div>
<a id="a8e2045e00166f79baf0b9a2bef020ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2045e00166f79baf0b9a2bef020ea2">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the id to be printed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The std::ostream to which the underlying id is printed </td></tr>
    <tr><td class="paramname">id</td><td>This id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the std::ostream for chaining </dd></dl>

</div>
</div>
<a id="a42c614b91880492ceb6026dec34435ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c614b91880492ceb6026dec34435ea">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmbe_1_1_handle_i_d.html">HandleID</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables two ids to be compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Left operand </td></tr>
    <tr><td class="paramname">right</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the underlying ids are equal, false otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/Adrian/Desktop/GameDev/Mars Base Project/Mars Base Engine ECS/Include/MBE/Core/<a class="el" href="_handle_i_d_8h_source.html">HandleID.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
